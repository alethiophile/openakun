* Things to do
** DONE Set up real per-instance configuration
   CLOSED: [2017-09-25 Mon 19:46]
 - Set database url, secret key?
   - This file may well end up with secret info in it, be careful
 - Not debug mode; that can only be set by the envar
 - Some verbosity level, though
   - Engine echo SQL?
 - Sentry DSN, once that's integrated
 - Password hash parameters (hash, security level)
   - Don't allow the known bad ones
*** TODO add Flask config to openakun.cfg
 - Have a section Flask that gets dumped into flask config
   - ast.literal_eval to get around the issue with strings vs. Python
     objects
** TODO Write view/post story functions
 - Need to add functionality for votes
*** TODO display posts better
 - include date of posting
*** TODO set up UI for chapters
*** TODO tune Quill editors for real markup abilities
 - incl. achievement links
** TODO Write realtime engine
 - Difficult to unit-test
 - Make sure to track time-on-page for proxy detection
 - When write-ins, add a show/hide for all the suggestions
*** TODO figure out DB layout
*** TODO implement votes frontend
** TODO Figure out E-mail
 - How to test this?
 - Make it an optional item; if you want you can run an instance without using
   it at all
   - In that case, let users not provide it?
** DONE Write test suite
   CLOSED: [2017-09-25 Mon 19:51]
** TODO Write a real frontend
 - CSS is awful
** TODO Make per-instance configuration better
 - How to find the configuration file?
** TODO Write more tests
 - Test the anti-XSS backend lots; look for lists of test cases
 - How to test realtime engine?
** TODO Figure out Sentry, add a setup
 - May wait until I've got a public instance
** TODO Set up good static file serving
 - Hash in URL path (probably just sha512)
   - Break up by path, something like 01/23/456789ab(...)f.filename.js or
     whatever
   - Configure nginx so that it gives the last bit as content-disposition
     filename
 - From inside app, identify files by hash (write an auxiliary url_for)
 - Use for both assets (js/css) and images; mostly latter
 - Configure caching with very long TTL; the same URL will never change, because
   hash
 - Good synergy with a CDN, if we ever do that

* Realtime engine architecture
 - Based on socketIO/eventlet (Flask-SocketIO)
 - That provides rooms already, supports most chat functionality
 - For "rooms", each story gets one, so does each user
   - Story funnels story chat, live updates/edits, votes
   - User funnels PM chat, followed story updates
 - For user actions that will come back through a room, use own ping to confirm
   receipt (UI like Discord, show it greyed out or something)
   - How to ensure consistent states?
   - Should probably implement ack'd messages in any case (dumb and slow across
     TCP, but should handle disconnect/reconnect, refresh, &c.)
     - How does this work with rooms?

* Database schema
 - Users, stories, chapters, posts, as current
 - Chat messages, private chat messages
   - Probably have a "conversations" table to facilitate private
 - User settings (probably just on the current User table?)
   - "is currently anon" as a setting?
   - Possible: anons can do settings too, in session object
 - Author/story follows
   - Have these as separate notions?
 - Log of actions
   - Log: users logging in/out, all user info changes, user email verification
     (registration is implicit in the user row), all stages of password reset
     process, all edits to posts?
 - Achievements, which users have seen which achievements
 - Votes/writeins
   - Each vote as a separate entry? store who votes for what, anons?
 - Anon sessions? Implicit user data by IP?
 - Bans (many-many, story to user-or-anon)
 - Reviews, likes

* Feature requests
 - Ability to delete writeins
 - Ability to change multivote and writein permission on a vote
   without closing and redoing it
   - How to deal with existing multivotes if turning multivote off?
     Just don't allow that?
