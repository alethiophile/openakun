* Things to do
** DONE Set up real per-instance configuration
   CLOSED: [2017-09-25 Mon 19:46]
 - Set database url, secret key?
   - This file may well end up with secret info in it, be careful
 - Not debug mode; that can only be set by the envar
 - Some verbosity level, though
   - Engine echo SQL?
 - Sentry DSN, once that's integrated
 - Password hash parameters (hash, security level)
   - Don't allow the known bad ones
*** TODO add Flask config to openakun.cfg
 - Have a section Flask that gets dumped into flask config
   - ast.literal_eval to get around the issue with strings vs. Python
     objects
** TODO Write view/post story functions
 - Need to add functionality for votes
 - Vote function:
   - realtime engine messages: vote, un-vote, create new option, create new
     writein, edit writein
   - to client messages: tally changed, new option/writein created, option
     killed, writein edited
   - while vote is active, numbers are tracked in Redis; when closed, copied to
     Postgres
   - when vote is rendered, need to show which options current user is voting
     for
*** TODO display posts better
 - include date of posting
*** TODO set up UI for chapters
*** TODO tune Quill editors for real markup abilities
 - incl. achievement links
** TODO Write realtime engine
 - Difficult to unit-test
 - Make sure to track time-on-page for proxy detection
 - When write-ins, add a show/hide for all the suggestions
*** TODO figure out DB layout
*** TODO implement votes frontend
** TODO Figure out E-mail
 - How to test this?
 - Make it an optional item; if you want you can run an instance without using
   it at all
   - In that case, let users not provide it?
*** TODO Write E-mail verification/password recovery code
 - Works by sending a random token to the E-mail given
 - Store tokens + expirations in a table (or two?)
   - Table: hashed token, user, expiration, purpose
   - Periodically clean DB of expired tokens
 - A route for each purpose (verify, reset password) with tokens in
   GETDATA
   - Also have ID for token table entry
 - Can only use E-mail to reset password if E-mail is already verified
   - Actually, this applies to sending any E-mail at all
** DONE Write test suite
   CLOSED: [2017-09-25 Mon 19:51]
** DONE Write a real frontend
 - CSS is awful
** TODO Make per-instance configuration better
 - How to find the configuration file?
** TODO Write more tests
 - Test the anti-XSS backend lots; look for lists of test cases
 - How to test realtime engine?
** DONE Figure out Sentry, add a setup
 - May wait until I've got a public instance
** TODO Set up good static file serving
 - Hash in URL path (probably just sha512)
   - Break up by path, something like 01/23/456789ab(...)f.filename.js or
     whatever
   - Configure nginx so that it gives the last bit as content-disposition
     filename
 - From inside app, identify files by hash (write an auxiliary url_for)
 - Use for both assets (js/css) and images; mostly latter
 - Configure caching with very long TTL; the same URL will never change, because
   hash
 - Good synergy with a CDN, if we ever do that
 - Method: files just go under static/ during development; have a function to
   take a hash and get a proper static url; static resources can just be
   identified by hash; images store hash in DB, fetch as necessary
 - separate origins for static and images (configurable in site config)
 - Cache-Control: max-age=31536000, immutable, no-transform
** TODO Think about routes, dice
 - Routes: list of chapters? chapter DAG? how to deal with contents listing?
   - Normal case is still single throughout, make sure not to compromise that
   - Would be nice for routes to be a bit less of an afterthought, though
 - Dice: how? just another variant of posts, QM can post rolls?
   - what options? make sure to include best- or worst-of-n, that's a popular
     one
   - players able to roll dice? in chat, e.g.?
** TODO autodiscover proxy setup on install
 - Probably only doable once there's a web-based installer
 - Check the remote IP/access_route, display it to user, ask them which entries
   are their configured reverse proxies
 - Use this to configure ProxyFix or similar
** TODO Set up per-deploy salt for IP hashes
 - Since anons are identified by IP hash, need to be sure people can't just
   brute-force it
 - Add a consistent server-side salt that's appended first
 - Probably shouldn't just make it the secret key; that can implicitly be
   changed, whereas salt will break all anon-identifying functions if it changes
 - Store in database? A "config" table?
** TODO Image storage considerations
 - Images are stored in static area by hash, as above
 - Also stored in DB; save hash name/path, which user uploaded, thumbnails
 - Generate thumbnails at upload time
 - In stories/topics, have normal <img> tags with src= pointing to the static area
   - In bleach rules, allow only img tags pointing to that area
 - In chat, have an "image" attribute with URL, which JS renders into an img tag
   at receive time
 - Image upload dialog: three choices: upload local, use URL, use your prior image
   - hence uploader tag on image in DB
   - How to deal with multiple users uploading same image? Plain many-to-many
     relationship?
   - Log every image uploaded
** DONE Set up Redis for caching
 - Start with caching channel auth, rather than the MAC setup
 - Redis needs to be set with AOF persistence for chat correctness
*** TODO Consider making Redis optional?
** TODO Set up Celery for periodics
 - Use to delete expired rows in tokens table
 - Also useful for sending out E-mails
** TODO Figure out Content-Security-Policy
 - Split out as much JS code as possible, put in static scripts
 - Static scripts can be served from separate origin (subdomain), maybe just
   same as main site
 - Images should be separate from this (in particular, not allowed as
   resources), since users can upload them and heaven knows someone's probably
   got a polyglot of JS/GIF somewhere
 - For inline scripts (used to communicate to client-side), use nonce; pattern
   is like CSRF tokens, except in g (ephemeral per request) rather than session
   - May need to use an after_request function to add necessary headers
 - Potentially, instead of an origin that allows scripts, just embed the hashes
   of all the scripts we include (probably via a make_script_tag helper function
   and another after_request)
   - This saves special-casing CDN origins, at least
 - Make it configurable; do CSP off/report-only/on
 - Set up receiving reports; log these through the normal event log
   - Need an "urgent" flag on the log

* Requirements before test deployment
** DONE Set up error logging (Sentry)
** TODO User profile, account management
** DONE Chapter UI
** DONE Fix UI arrangement
** TODO Log user actions
** TODO User privileges for log viewing

* Design
** Realtime engine architecture
 - Based on socketIO/eventlet (Flask-SocketIO)
 - That provides rooms already, supports most chat functionality
 - For "rooms", each story gets one, so does each user
   - Story funnels story chat, live updates/edits, votes
   - User funnels PM chat, followed story updates
 - For user actions that will come back through a room, use own ping to confirm
   receipt (UI like Discord, show it greyed out or something)
   - How to ensure consistent states?
   - Should probably implement ack'd messages in any case (dumb and slow across
     TCP, but should handle disconnect/reconnect, refresh, &c.)
     - How does this work with rooms?
 - Realtime actions mostly go via Redis; copied to main DB in batch mode
   - Chat messages go in Redis on receipt (and are re-broadcast), Celery task
     copies them to DB once per minute
   - Chat backlog requests come from Redis
   - Active votes are stored in Redis exclusively while active, copied to DB
     when QM closes the vote
   - If QM reopens a vote, data from DB is copied back to Redis again for
     duration
 - For story chat, the SocketIO room is simply the story's channel ID
 - For PM chat, a separate channel in the DB is made for each pair of users who
   PM, but updates via SocketIO are funneled via the user's room (thus the
   equivalence between channel and room is broken)

** Database schema
 - Users, stories, chapters, posts, as current
   - Story: need to add word count, last updated, live and live timer
   - User: add whether E-mail is verified
 - Vote schema:
   - Store per vote: vote settings like multivote/hidden vote; start and end
     times; active status
   - Store per vote entry: who's voting for it; whether it's been killed by QM;
     kill message if any; who created it? (is this necessary?)
   - Store per write-in: who created it
 - Chat messages, private chat messages
   - Probably have a "conversations" table to facilitate private
   - Chat: "messages" table, "rooms" table
   - Messages is obvious
   - Rooms are what hold messages; each story has a room; private chats create a
     room private to the users involved
     - Make sure to have proper access controls on those
     - "Room" has a column "private" boolean for whether it's access-controlled;
       then also a many-to-many table rooms to users
   - This can potentially support creating arbitrary rooms, later, but that's
     maybe extraneous
 - User settings (probably just on the current User table?)
   - "is currently anon" as a setting?
   - Possible: anons can do settings too, in session object
 - Author/story follows
   - Have these as separate notions?
 - Log of actions
   - Log: users logging in/out, all user info changes, user email verification
     (registration is implicit in the user row), all stages of password reset
     process, all edits to posts?, any HTML sanitization failures (log those in
     Sentry too?), 
   - Rate limiting: refer to log, possibly optimize via redis
   - Limit: stories created/time, stories live at once, chat messages/time (high
     limit, maybe 30/min), password reset attempts/time, login attempts/time,
     topics created/time
   - Log structure: timestamp, object type, object ID, user ID, event type,
     info, urgency flag, seen flag
 - Achievements, which users have seen which achievements
 - Votes/writeins
   - Each vote as a separate entry? store who votes for what, anons?
 - Anon sessions? Implicit user data by IP?
 - Bans (many-many, story to user-or-anon)
 - Reviews, likes

** Markup text
 - To avoid XSS, we're very strict about what markup user-generated text can contain
 - Fields that allow markup are text posts, story descriptions only (other
   user-generated text is universally HTML-escaped via jinja2)
 - For user-generated markup, HTML is processed via bleach, which is a
   whitelist-based sanitization library
 - Allowed tags are only:
   - basic inline markup: i, em, b, strong, s, strike
   - basic other markup: br, ul, ol, li, p
   - images: only allowed from the configured image origin (all images are
     mirrored and served by openakun); only attribute allowed is 'src'
   - achievements: implemented with 'a' tag, no 'href' ever allowed, passes
     'class="achieve-link"' and 'data-achieve="name"' only
 - HTML is scanned on upload; if any forbidden elements are found, the request
   is denied and logged
 - On client end, rich text editor generates known-good HTML; HTML
   cleaning/scanning should be transparent to ordinary users
* Feature requests
 - Ability to delete writeins
 - Ability to change multivote and writein permission on a vote
   without closing and redoing it
   - How to deal with existing multivotes if turning multivote off?
     Just don't allow that?
 - Ability to hide writein sections while reading through
 - Display votes in descending order after close, even if they had hidden vote
   totals while open

* UI elements
 - Site main page link, possibly logo/brand
 - Site main menu
   - Another home link, view categories, about page, post new story
   - Maybe some user preferences like posting as anon or light/dark theme
     - Use [[https://github.com/thomaspark/bootswatch][Bootswatch]] for themes
 - Story main menu
   - Like/follow/review, display preferences?
   - Contents page
     - Some routes UI here, if doing that
 - User prefs area, login link if not logged in, link to profile if so
* Deploy process
 - Need to install:
   - postgresql-server
   - postgresql-devel
   - certbot
   - nginx
   - firewall (ufw or firewalld)
   - redis
   - build-essential (~yum groupinstall "Development Tools"~)
   - python38
   - python38-devel
   - openssl-devel
 - Set up nginx for reverse proxying
   - HTTP proxy
 - Create a virtualenv and activate it
 - Get the dist and run: ~pip3 install --upgrade openakun-x.y.z.tar.gz~
 - run the worker:
   - in development, you run:
     ~celery -A openakun.tasks.queue worker --loglevel INFO -B~
     which runs the beat scheduler in the same process as a single worker
   - in production, you need to run ~celery beat~ in a separate process, and
     maybe multiple workers for load-sharing
 - run the server:
   ~openakun_server~
